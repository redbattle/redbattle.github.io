(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{377:function(a,s,v){"use strict";v.r(s);var t=v(8),_=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"重绘重排"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘重排"}},[a._v("#")]),a._v(" 重绘重排")]),a._v(" "),s("ul",[s("li",[a._v("重排，dom 的变化影响到了几何属性，浏览器重新计算元素的几何属性，其他元素的几何属性和位置也会发生变化，浏览器需要重新构造渲染树")]),a._v(" "),s("li",[a._v("引起重排，规模尺寸，布局，隐藏显示")]),a._v(" "),s("li",[a._v("重绘，浏览器将受影响的元素重新绘制到屏幕上的过程称为重绘")]),a._v(" "),s("li",[a._v("引起重绘，改变元素外观属性，比如 color，background-color")]),a._v(" "),s("li",[a._v("重排必定重绘，重绘不一定重排")]),a._v(" "),s("li",[a._v("优化\n"),s("ul",[s("li",[a._v("减少重绘重排的操作，合并多次 DOM 和样式的修改操作；")]),a._v(" "),s("li",[a._v("使用 fragment 创建虚拟节点")]),a._v(" "),s("li",[a._v("将需要多次重排重绘的元素 position 属性改为 absolute 或 fixed，使其脱离文档流")])])])]),a._v(" "),s("h3",{attrs:{id:"盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型"}},[a._v("#")]),a._v(" 盒子模型")]),a._v(" "),s("ul",[s("li",[a._v("水平垂直居中方法：\n"),s("ul",[s("li",[a._v("display: flex")]),a._v(" "),s("li",[a._v("display: table-cell")]),a._v(" "),s("li",[a._v("js")]),a._v(" "),s("li",[a._v("定位")])])]),a._v(" "),s("li",[a._v("标准盒模型，大小=content+padding+border+margin。box-sizing: content-box")]),a._v(" "),s("li",[a._v("ie 盒模型，大小=content+margin。box-sizing: border-box")])]),a._v(" "),s("h3",{attrs:{id:"布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#布局"}},[a._v("#")]),a._v(" 布局")]),a._v(" "),s("ul",[s("li",[a._v("弹性布局")]),a._v(" "),s("li",[a._v("圣杯布局，浮动和负 margin")]),a._v(" "),s("li",[a._v("双飞翼布局")]),a._v(" "),s("li",[a._v("左右固定，中间自适应")])]),a._v(" "),s("h3",{attrs:{id:"弹性布局优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#弹性布局优缺点"}},[a._v("#")]),a._v(" 弹性布局优缺点")]),a._v(" "),s("h3",{attrs:{id:"响应式布局优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应式布局优缺点"}},[a._v("#")]),a._v(" 响应式布局优缺点")]),a._v(" "),s("h3",{attrs:{id:"伪类和伪元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#伪类和伪元素"}},[a._v("#")]),a._v(" 伪类和伪元素")]),a._v(" "),s("ul",[s("li",[a._v("::before，伪元素")]),a._v(" "),s("li",[a._v(":before，伪类")])]),a._v(" "),s("h3",{attrs:{id:"骨架屏的实现思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#骨架屏的实现思路"}},[a._v("#")]),a._v(" 骨架屏的实现思路")]),a._v(" "),s("h3",{attrs:{id:"过渡和动画效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过渡和动画效果"}},[a._v("#")]),a._v(" 过渡和动画效果")]),a._v(" "),s("ul",[s("li",[a._v("css3 动画\n"),s("ul",[s("li",[a._v("animation，定义动画帧的效果（@keyframes，设置帧）")]),a._v(" "),s("li",[a._v("transition，定义元素变化过程中的行为")]),a._v(" "),s("li",[a._v("transform，定义元素变化结果")]),a._v(" "),s("li",[a._v("优点：浏览器对 css3 会做优化，性能更好")]),a._v(" "),s("li",[a._v("缺点：兼容性不好，动画控制不够灵活")])])]),a._v(" "),s("li",[a._v("js 动画\n"),s("ul",[s("li",[a._v("优点：动画控制好，兼容性好")])])])]),a._v(" "),s("h3",{attrs:{id:"系统分辨率和固定分辨率优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#系统分辨率和固定分辨率优缺点"}},[a._v("#")]),a._v(" 系统分辨率和固定分辨率优缺点")]),a._v(" "),s("h3",{attrs:{id:"display-none-与-visibility-hidden"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#display-none-与-visibility-hidden"}},[a._v("#")]),a._v(" display:none 与 visibility:hidden")]),a._v(" "),s("h3",{attrs:{id:"canvas-动画"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canvas-动画"}},[a._v("#")]),a._v(" canvas 动画")]),a._v(" "),s("ul",[s("li",[a._v("threejs")]),a._v(" "),s("li",[a._v("白鹭引擎")]),a._v(" "),s("li",[a._v("虚幻 4")])]),a._v(" "),s("h3",{attrs:{id:"webgl-svg-canvas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webgl-svg-canvas"}},[a._v("#")]),a._v(" WebGL\\SVG\\Canvas")]),a._v(" "),s("h3",{attrs:{id:"canvas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canvas"}},[a._v("#")]),a._v(" canvas")]),a._v(" "),s("ul",[s("li",[a._v("Canvas 通过 JavaScript 来绘制 2D 图形，Canvas 只是一个 HTML 元素，其中的图形不会单独创建 DOM 元素。因此我们不能通过 JavaScript 操控 Canvas 内单独的图形，不能对其中的具体图形进行监控")]),a._v(" "),s("li",[a._v("在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象")]),a._v(" "),s("li",[a._v("标量图，放大缩小会失真")])]),a._v(" "),s("h3",{attrs:{id:"svg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#svg"}},[a._v("#")]),a._v(" svg")]),a._v(" "),s("ul",[s("li",[a._v("svg 创建的每一个元素都是一个独立的 DOM 元素，既然是独立的 DOM 元素，那么我们就可以通过 css 和 JavaScript 来操控 dom。可以对每一个 DOM 元素进行监听。")]),a._v(" "),s("li",[a._v("并且因为每一个元素都是一个 DOM 元素，所以修改 svg 中的 DOM 元素，系统会自动进行 DOM 重绘")]),a._v(" "),s("li",[a._v("矢量图，放大缩小不会失真")])]),a._v(" "),s("h3",{attrs:{id:"margin-塌陷"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#margin-塌陷"}},[a._v("#")]),a._v(" margin 塌陷")]),a._v(" "),s("ul",[s("li",[a._v("同级元素设置 margin 上下边距会出现合并")]),a._v(" "),s("li",[a._v("父子元素，子元素设置上边距，会传递到父元素")]),a._v(" "),s("li",[a._v("解决：\n"),s("ul",[s("li",[a._v("父盒子设置透明 border")]),a._v(" "),s("li",[a._v("父盒子添加 overflow：hidden")]),a._v(" "),s("li",[a._v("父盒子设定 padding 值")]),a._v(" "),s("li",[a._v("伪元素给子元素的前面添加一个空元素")])])])]),a._v(" "),s("h3",{attrs:{id:"行内元素-float-后的效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行内元素-float-后的效果"}},[a._v("#")]),a._v(" 行内元素 float 后的效果")]),a._v(" "),s("ul",[s("li",[a._v("行内元素 float 后变得像是 inline-block，同时拥有行内和块级的特性，最明显的不同是默认 width 不是 100%，可以设置 padding、width、height")])]),a._v(" "),s("h3",{attrs:{id:"sass-less-stylus"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sass-less-stylus"}},[a._v("#")]),a._v(" sass/less/stylus")]),a._v(" "),s("ul",[s("li",[a._v("具有变量，缓和，嵌套，继承，颜色混合等基本特性")]),a._v(" "),s("li",[a._v("less 需要{}，sass/stylus 可以缩进表示嵌套关系")]),a._v(" "),s("li",[a._v("scss 无全局变量的概念，less/stylus 有作用域的概念")]),a._v(" "),s("li",[a._v("sass 基于 ruby，less/styleus 基于 nodejs")])]),a._v(" "),s("h3",{attrs:{id:"css-实现硬件加速"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-实现硬件加速"}},[a._v("#")]),a._v(" css 实现硬件加速")]),a._v(" "),s("ul",[s("li",[a._v("硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能")]),a._v(" "),s("li",[a._v("一般触发硬件加速的 css 属性有：transform、opacity、filter，为了避免 2d 动画在开始和结束的时候重绘操作，一般使用 transform: translateZ(0)")])])])}),[],!1,null,null,null);s.default=_.exports}}]);