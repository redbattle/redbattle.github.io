(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{383:function(v,l,_){"use strict";_.r(l);var a=_(8),i=Object(a.a)({},(function(){var v=this,l=v._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h3",{attrs:{id:"webpack"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[v._v("#")]),v._v(" Webpack")]),v._v(" "),l("ul",[l("li",[v._v("模块打包工具，可以管理模块依赖，并能编译出模块需要的静态资源文件")]),v._v(" "),l("li",[v._v("可以很好的管理打包 web 需要的 html、css、js、image、font 等，让开发过程更高效")]),v._v(" "),l("li",[v._v("对不同类型的资源有对应的模块加载器")]),v._v(" "),l("li",[v._v("打包器会分析模块间的依赖关系生成优化且合并后的静态资源")]),v._v(" "),l("li",[v._v("构建优化\n"),l("ul",[l("li",[v._v("减少编译体积，IgnorePlugin，babel-plugin-import，babel-plugin-transform-runtime")]),v._v(" "),l("li",[v._v("并行编译，happypack，thread-loader，uglifyjsWebpackPlugin")]),v._v(" "),l("li",[v._v("缓存，cache-loader，hard-source-webpack-plugin，babel-loader")]),v._v(" "),l("li",[v._v("预编译，dllWebpackPlugin，DllReferencePlugin，auto-dll-webpack-plugin")])])]),v._v(" "),l("li",[v._v("性能优化\n"),l("ul",[l("li",[v._v("减少编译体积，Tree-shaking，scope hositing")]),v._v(" "),l("li",[v._v("hash 缓存，webpack-md5-plugin")]),v._v(" "),l("li",[v._v("拆包，splitChunksPlugin，import，require.ensure")])])])]),v._v(" "),l("h3",{attrs:{id:"异步编程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[v._v("#")]),v._v(" 异步编程")]),v._v(" "),l("ul",[l("li",[v._v("回调函数\n"),l("ul",[l("li",[v._v("优点：简单容易理解")]),v._v(" "),l("li",[v._v("缺点：不利于维护，代码耦合高")])])]),v._v(" "),l("li",[v._v("事件监听（采用事件驱动模式，取决于事件是否发生）\n"),l("ul",[l("li",[v._v("优点：容易理解，可以绑定多个事件，每个事件可以绑定多个回调函数")]),v._v(" "),l("li",[v._v("缺点：事件驱动型，流程不够清晰")])])]),v._v(" "),l("li",[v._v("观察者模式（发布订阅）\n"),l("ul",[l("li",[v._v("类似于事件监听，但是可以通过消息监听可以了解现在有多少个订阅者和发布者")]),v._v(" "),l("li",[v._v("promise 对象\n"),l("ul",[l("li",[v._v("优点：可以用 then 方法链式调用，可以书写错误时的回调函数")]),v._v(" "),l("li",[v._v("缺点：编写和理解比较难")])])]),v._v(" "),l("li",[v._v("Generator 函数\n"),l("ul",[l("li",[v._v("优点：函数体内的数据交换、错误处理机制")]),v._v(" "),l("li",[v._v("缺点：流程管理不方便")])])]),v._v(" "),l("li",[v._v("async 函数\n"),l("ul",[l("li",[v._v("优点：内置执行器，更好的语义，更广的适用性，返回的是 promise，结构清晰")]),v._v(" "),l("li",[v._v("缺点：错误处理机制")])])])])])]),v._v(" "),l("h3",{attrs:{id:"函数式编程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[v._v("#")]),v._v(" 函数式编程")]),v._v(" "),l("h3",{attrs:{id:"脚手架工具"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#脚手架工具"}},[v._v("#")]),v._v(" 脚手架工具")]),v._v(" "),l("h3",{attrs:{id:"自动化构建"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#自动化构建"}},[v._v("#")]),v._v(" 自动化构建")]),v._v(" "),l("h3",{attrs:{id:"自动化测试"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#自动化测试"}},[v._v("#")]),v._v(" 自动化测试")]),v._v(" "),l("h3",{attrs:{id:"自动化部署"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#自动化部署"}},[v._v("#")]),v._v(" 自动化部署")]),v._v(" "),l("h3",{attrs:{id:"开发规范"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#开发规范"}},[v._v("#")]),v._v(" 开发规范")]),v._v(" "),l("h3",{attrs:{id:"重构"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重构"}},[v._v("#")]),v._v(" 重构")]),v._v(" "),l("h3",{attrs:{id:"mvc-和-mvvm-的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#mvc-和-mvvm-的区别"}},[v._v("#")]),v._v(" MVC 和 MVVM 的区别")]),v._v(" "),l("ul",[l("li",[v._v("MVC 单向数据绑定，需要手动绑定事件来影响数据")]),v._v(" "),l("li",[v._v("MVVM 双向数据绑定")]),v._v(" "),l("li",[v._v("MVC 比 MVVM 少了视图改变影响数据")]),v._v(" "),l("li",[v._v("MVC\n"),l("ul",[l("li",[v._v("View 接受用户交互请求")]),v._v(" "),l("li",[v._v("View 将请求转交给 Controller 处理")]),v._v(" "),l("li",[v._v("Controller 操作 Model 进行数据更新保存")]),v._v(" "),l("li",[v._v("数据更新保存之后，Model 会通知 View 更新")]),v._v(" "),l("li",[v._v("View 更新变化数据使用户得到反馈")])])]),v._v(" "),l("li",[v._v("MVVM\n"),l("ul",[l("li",[v._v("Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑")]),v._v(" "),l("li",[v._v("View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来")]),v._v(" "),l("li",[v._v("ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View")])])])]),v._v(" "),l("h3",{attrs:{id:"设计模式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),l("ul",[l("li",[v._v("观察者模式/发布订阅，")]),v._v(" "),l("li",[v._v("工厂模式，解决重复实例化，可以消除对象间的耦合")]),v._v(" "),l("li",[v._v("构造函数模式，既解决了重复实例化的问题，又解决了对象识别的问题，直接将方法和属性赋值给对象")])])])}),[],!1,null,null,null);l.default=i.exports}}]);