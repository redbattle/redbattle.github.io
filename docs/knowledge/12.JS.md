---
title: JS
date: 2022-01-21 16:13:42
permalink: /pages/1899f2/
categories:
  - knowledge
tags:
  -
---

### 原型和原型链

    - 每个对象都会在内部初始化一个属性prototype，当访问对象的属性时，如果这个对象内部不存在这个属性，就会去prototype里找这个属性，这个prototype又会有自己的prototype属性，这样一直找下去就是原型链概念
    - 优先取构造函数的上属性
    - 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。
    - 每个对象都有__proto__属性，指向了创建该对象的构造函数的原型。其实这个属性指向了prototype，但是prototype是内部属性，我们并不能访问到，所以使用_proto_来访问。
    - 对象可以通过 __proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链。
    - 原型链的终集是null

### 防抖和节流

    - 防抖，触发事件后在一段时间内只执行一次，若在这段时间内再次触发则会重新计算执行时间
    - 节流，连续发生的事件在一段时间内只执行一次，节流会减少执行频率

### es6 转 es5 的实现思路

### call、apply、bind 的区别

    - 都可以改变指针的对象，将函数放到特定作用域中执行
    - call 函数名.call(作用域对象, 多个参数)
    - apply 函数名.apply(作用域对象, 数组参数)
    - bind 绑定作用域 函数名.bind(作用域对象, 多个参数)

### void 0 与 undefined

### this 指向

    - 指向函数的直接调用者，而非间接调用者，如果该对象没有对应属性，则不会再往上一层查找
    - 如果有new关键字，this指向new出来的那个对象
    - 在事件中，this指向触发这个事件的对象，特殊情况IE中attachEvent的this总是指向window
    - 箭头函数指向定义时的this

### 闭包

    - 在函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链
    - 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁，用完需要对闭包做null的处理手动销毁
    - 作用域链，如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，查找过程形成的链条就叫做作用域链
    - 优点：
        - 避免全局变量的污染
        - 封装对象的私有属性和方法
    - 缺点：
        - 会常驻内存，增大内存使用量
        - 使用不当会造成内存泄露

### 混合

### 继承

    - 构造继承，函数内使用call、apply调用
    - 原型继承，设置prototype属性

### 模板引擎

    - 模板引擎负责组装数据，将变量模板编译成浏览器能识别的代码

### Flux

### 同构

### 浅拷贝

    只拷贝第一层
    - 循环
    - es6解构
    - Object.assign()

### 深拷贝

    - json转换，正则、函数、会变成{}，日期会变成字符串
        - 不能序列化函数
        - 会忽略undefined
        - 不能解决循环引用的对象
    - 递归，判断正则、日期、函数等特殊类型

### 面向对象

    - 将对象方法封装成相互独立的模块
    - 以功能来划分

### 面向过程

    - 分析出解决问题所需要的步骤，然后一步一步解决

### 多线程实现

    - 单线程原因：避免dom渲染的冲突
    - webworker支持多线程，但是不能操作dom

### 遍历（异步遍历，提前返回问题）

    - forEach(item, index, array) 类似for循环，没有返回值。IE不支持，无法使用break，continue跳出循环，使用return跳出循环
    - map(item, index) 需要返回值
    - reduce((prev, item, index) => {}, initValue) 对数组中每个元素执行回调，并将累计结果返回给下一个回调
    - for...in 可以遍历对象
    - for...of

### 模块化开发

    - 立即执行函数不暴露私有属性

### 懒加载原理

    图片加载是由src的值引起的，当对src进行赋值时浏览器会请求图片资源，可以用html5属性data-xxx来保存图片路径，当需要显示图片时，再将data-xxx的值赋给src，实现按需加载

### 异步加载 js

    - defer(只支持IE)，async
    - 创建script，插入到dom中，再执行callback

### 装饰器

    - 对类或属性方法加上前置操作
    - 实现复用

### 异步

    - 执行顺序，一个宏任务里必须执行完所有微任务才会执行下一个宏任务，同级先微任务后宏任务
    - 宏任务：定时器、事件绑定、ajax
    - 微任务：async、await、promise

### fetch

    - 基于promise，支持async/await
    - 需要进行封装
    - 只对网络请求报错，400，500均为正常
    - 默认不会带cookie，需要配置项。fetch(url, {credentials: 'include'})
    - 不支持超时控制。使用setTimeout及promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行
    - 没有办法原生监测请求的进度

### axios

    - 支持浏览器和nodejs发请求
    - 支持promise
    - 客户端支持防CSRF
    - 提供了一些并发请求的接口
    - 拦截请求和响应
    - 取消请求
    - 自动转换json数据
    - 监测请求的进度

### 多标签页之间的通信

    - localStorage，页面a使用localStorage.setItem存储值，页面b监听storage事件
    - cookie，页面a存储值，页面b轮询cookie值
    - websocket，全双工通信，服务器可以主动发数据，页面a发送数据到服务器，服务器发送数据到页面b
    - sharedWorker，多页面多线程

### 判断类型

    ```
    Object.prototype.toString.call(value).slice(8, -1)
    ```
    - typeof
        - 对于原始类型来说，除了 null 都可以显示正确的类型
        - 对于对象来说，除了函数都会显示 object
    - instanceof
        - 可以正确的判断对象的类型，因为内部机制是通过对象prototype原型链判断

### 比较运算符 ==

    - 对象/数组==字符串，会转换成字符串
    - null==undefined，与其他值不相等
    - NAN!=NAN
    - 对象/数组==数字，会先转换成字符串，然后再转换成数字
    - 剩下的都是转换成数字

### 事件代理

    - 把原本需要绑定的事件委托给父元素，让父元素监听处理多个子元素
    - 事件代理的原理是dom事件冒泡，使用事件代理的好处是可以提高性能，节省内存空间，减少事件注册
    - 可以实现新增子对象是无需再次对其绑定

### 事件

    - 事件冒泡，子元素先触发，父元素后触发
    - 时间捕获，父元素先触发，子元素后触发
    - dom事件流，同时支持冒泡和捕获，document.addEventListener()，第三个参数true表示捕获，false表示冒泡
    - 阻止冒泡，w3c使用stopPropagation()，IE使用cancelBubble = true
    - 阻止捕获，阻止事件的默认行为，w3c中使用preventDefault()，IE中设置window.event.returnValue = false

### new 操作符

    - 创建一个新对象，并且this变量引用该对象，同时还继承了该函数的原型
    - 属性和方法被加入到this引用的对象中
    - 隐式返回this

### ajax

    - 创建xhr连接
    - 设置参数，并打开连接
    - 发送请求
    - 接收请求
    - 优点
        - 异步请求提升了用户体验
        - 实现局部数据更新
    - 缺点
        - 安全问题，ajax暴露了客户端与服务器交互细节
        - 对搜索引擎支持弱，不利于seo

### 内存泄露

    - 闭包使用不当，不需要的对象仍存在于内存中
    - 死循环

### 垃圾回收

    - 在 `JavaScript` 引擎中有一个被称作 `垃圾回收器` 的东西在后台执行，它监控着所有对象的状态，并删除掉那些已经不可达的
    - 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的。比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 该 对象被认为是可达的。而且它引用的内容也是可达的
    - 固有的可达值的基本集合，这些值被称作 `根`（`roots`）
        - 当前执行的函数，它的局部变量和参数
        - 当前嵌套调用链上的其他函数、它们的局部变量和参数
        - 全局变量
    - 定期执行以下“垃圾回收”步骤
        - 垃圾收集器找到所有的根，并“标记”（记住）它们
        - 然后它遍历并“标记”来自它们的所有引用
        - 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象
        - 如此操作，直到所有可达的（从根部）引用都被访问到
        - 没有被标记的对象都会被删除

### AMD，Commonjs，ES6

    - AMD是异步加载模块，允许指定回调函数
    - AMD推荐通过返回一个对象作为模块对象
    - Commonjs是服务器端的模块规范，加载模块是同步的，只有模块加载完成才能执行后面的操作
    - Commonjs推荐通过module.exports或exports的属性赋值来达到暴露模块对象的目的
    - Commonjs支持动态导入，例如require(${path}/xx.js)，导出时是值拷贝，
    - ES6中一个模块就是一个文件，改文件内左右的变量和方法外部无法直接获取只能通过export输出
    - ES6异步加载，导入导出都指向同一个内存地址

### window.onload 和$(document).ready

    - window.onload必须等页面内所有元素（包括图片）加载完毕后才能执行
    - $(document).ready是dom结构绘制完毕后就会执行，不必等到加载完毕

### 判断标准浏览器和 IE 浏览器

    - 标准，document.addEventListener，支持冒泡和捕获，事件类型不需要添加on，添加多个事件正序执行
    - IE，document.attachEvent，支持冒泡，事件类型需要添加on，添加多个事件倒序执行

### event loop

### 事件流

### canvas 图片跨域
