<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | Redbattle</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="知识管理">
    <link rel="preload" href="/assets/css/0.styles.72b834ca.css" as="style"><link rel="preload" href="/assets/js/app.1b920942.js" as="script"><link rel="preload" href="/assets/js/2.a96424b1.js" as="script"><link rel="preload" href="/assets/js/34.d1e49084.js" as="script"><link rel="prefetch" href="/assets/js/10.63a1ff18.js"><link rel="prefetch" href="/assets/js/11.85e2c00f.js"><link rel="prefetch" href="/assets/js/12.71cb16f4.js"><link rel="prefetch" href="/assets/js/13.292a3b82.js"><link rel="prefetch" href="/assets/js/14.bc54ac57.js"><link rel="prefetch" href="/assets/js/15.7cc6e05e.js"><link rel="prefetch" href="/assets/js/16.eb145474.js"><link rel="prefetch" href="/assets/js/17.b6394de2.js"><link rel="prefetch" href="/assets/js/18.a1c96059.js"><link rel="prefetch" href="/assets/js/19.2665b226.js"><link rel="prefetch" href="/assets/js/20.ef853ef5.js"><link rel="prefetch" href="/assets/js/21.8f40738c.js"><link rel="prefetch" href="/assets/js/22.ecb941a9.js"><link rel="prefetch" href="/assets/js/23.b9975f7e.js"><link rel="prefetch" href="/assets/js/24.8ddeabf6.js"><link rel="prefetch" href="/assets/js/25.d843e92e.js"><link rel="prefetch" href="/assets/js/26.efb6440b.js"><link rel="prefetch" href="/assets/js/27.7076001e.js"><link rel="prefetch" href="/assets/js/28.078b400e.js"><link rel="prefetch" href="/assets/js/29.074be712.js"><link rel="prefetch" href="/assets/js/3.a95f1f96.js"><link rel="prefetch" href="/assets/js/30.225b9f40.js"><link rel="prefetch" href="/assets/js/31.b3e98356.js"><link rel="prefetch" href="/assets/js/32.26ba3f09.js"><link rel="prefetch" href="/assets/js/33.69263f8f.js"><link rel="prefetch" href="/assets/js/35.9ffc15bb.js"><link rel="prefetch" href="/assets/js/36.30792cc5.js"><link rel="prefetch" href="/assets/js/37.b2fde33b.js"><link rel="prefetch" href="/assets/js/38.7f50d7e1.js"><link rel="prefetch" href="/assets/js/39.28258b9d.js"><link rel="prefetch" href="/assets/js/4.a61f4757.js"><link rel="prefetch" href="/assets/js/40.fa49639e.js"><link rel="prefetch" href="/assets/js/41.1468d391.js"><link rel="prefetch" href="/assets/js/42.efc11588.js"><link rel="prefetch" href="/assets/js/43.a4045a68.js"><link rel="prefetch" href="/assets/js/44.3004a0d9.js"><link rel="prefetch" href="/assets/js/45.8b0d0b45.js"><link rel="prefetch" href="/assets/js/46.5cdc8f55.js"><link rel="prefetch" href="/assets/js/47.80e52332.js"><link rel="prefetch" href="/assets/js/48.a31619e5.js"><link rel="prefetch" href="/assets/js/49.08f25897.js"><link rel="prefetch" href="/assets/js/5.7b9e8321.js"><link rel="prefetch" href="/assets/js/50.8ab0307f.js"><link rel="prefetch" href="/assets/js/51.90b06123.js"><link rel="prefetch" href="/assets/js/52.5e70e7d4.js"><link rel="prefetch" href="/assets/js/53.f43b96eb.js"><link rel="prefetch" href="/assets/js/54.53cc516d.js"><link rel="prefetch" href="/assets/js/55.ed43ff5c.js"><link rel="prefetch" href="/assets/js/56.13cf6a58.js"><link rel="prefetch" href="/assets/js/57.71053195.js"><link rel="prefetch" href="/assets/js/58.37283f05.js"><link rel="prefetch" href="/assets/js/59.4525b295.js"><link rel="prefetch" href="/assets/js/6.c1214982.js"><link rel="prefetch" href="/assets/js/60.23de4620.js"><link rel="prefetch" href="/assets/js/61.4624e405.js"><link rel="prefetch" href="/assets/js/62.915d295a.js"><link rel="prefetch" href="/assets/js/63.f443e83c.js"><link rel="prefetch" href="/assets/js/64.0c8ee9d9.js"><link rel="prefetch" href="/assets/js/65.1cfe10ed.js"><link rel="prefetch" href="/assets/js/66.81627404.js"><link rel="prefetch" href="/assets/js/67.790412a6.js"><link rel="prefetch" href="/assets/js/68.de22ad17.js"><link rel="prefetch" href="/assets/js/69.9405974a.js"><link rel="prefetch" href="/assets/js/7.1f2bb07c.js"><link rel="prefetch" href="/assets/js/70.c19e60a8.js"><link rel="prefetch" href="/assets/js/71.383c2215.js"><link rel="prefetch" href="/assets/js/72.684f884f.js"><link rel="prefetch" href="/assets/js/73.ab50ae9f.js"><link rel="prefetch" href="/assets/js/74.e309c182.js"><link rel="prefetch" href="/assets/js/75.eb0405aa.js"><link rel="prefetch" href="/assets/js/76.80652294.js"><link rel="prefetch" href="/assets/js/8.2159784c.js"><link rel="prefetch" href="/assets/js/9.8871d80f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.72b834ca.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Redbattle</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fix/" class="nav-link">踩坑</a></div><div class="nav-item"><a href="/env/" class="nav-link">环境</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/setting/" class="nav-link">配置</a></div><div class="nav-item"><a href="/knowledge/" class="nav-link">知识点</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/fix/" class="nav-link">踩坑</a></div><div class="nav-item"><a href="/env/" class="nav-link">环境</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/setting/" class="nav-link">配置</a></div><div class="nav-item"><a href="/knowledge/" class="nav-link">知识点</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/ee5317/" class="sidebar-link">浏览器/网络</a></li><li><a href="/pages/3e5cfa/" class="sidebar-link">HTML</a></li><li><a href="/pages/b4f570/" class="sidebar-link">CSS</a></li><li><a href="/pages/1899f2/" aria-current="page" class="active sidebar-link">JS</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/9a1a46/" class="sidebar-link">Vue</a></li><li><a href="/pages/902358/" class="sidebar-link">ES6</a></li><li><a href="/pages/3ff343/" class="sidebar-link">TS</a></li><li><a href="/pages/ea74bb/" class="sidebar-link">格式化上下文</a></li><li><a href="/pages/701494/" class="sidebar-link">工程化</a></li><li><a href="/pages/631015/" class="sidebar-link">常用 Web 坐标转换</a></li><li><a href="/pages/e96e8f/" class="sidebar-link">算法</a></li><li><a href="/pages/77460d/" class="sidebar-link">安全性</a></li><li><a href="/pages/705ea2/" class="sidebar-link">CSS 选择器</a></li><li><a href="/pages/077fa8/" class="sidebar-link">CSS 函数</a></li><li><a href="/pages/da9adf/" class="sidebar-link">CSS 属性</a></li><li><a href="/pages/d22f7b/" class="sidebar-link">CSS @</a></li><li><a href="/pages/8e2c71/" class="sidebar-link">CSS 过渡与动画</a></li><li><a href="/pages/fbeceb/" class="sidebar-link">CSS 预处理器</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/categories/?category=knowledge" title="分类" data-v-1cd794fe>knowledge</a></li> <!----> <!----></ul> <div class="info" data-v-1cd794fe><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2022-01-21</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          JS
        </h1> <!----> <div class="theme-vdoing-content content__default"><h3 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h3> <ul><li>每个对象都会在内部初始化一个属性 prototype，当访问对象的属性时，如果这个对象内部不存在这个属性，就会去 prototype 里找这个属性，这个 prototype 又会有自己的 prototype 属性，这样一直找下去就是原型链概念</li> <li>优先取构造函数的上属性</li> <li>每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。</li> <li>每个对象都有<strong>proto</strong>属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 prototype，但是 prototype 是内部属性，我们并不能访问到，所以使用<em>proto</em>来访问。</li> <li>对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性，<strong>proto</strong> 将对象连接起来组成了原型链。</li> <li>原型链的终集是 null</li></ul> <h3 id="防抖和节流"><a href="#防抖和节流" class="header-anchor">#</a> 防抖和节流</h3> <ul><li>防抖，触发事件后在一段时间内只执行一次，若在这段时间内再次触发则会重新计算执行时间</li> <li>节流，连续发生的事件在一段时间内只执行一次，节流会减少执行频率</li></ul> <h3 id="es6-转-es5-的实现思路"><a href="#es6-转-es5-的实现思路" class="header-anchor">#</a> es6 转 es5 的实现思路</h3> <h3 id="call、apply、bind-的区别"><a href="#call、apply、bind-的区别" class="header-anchor">#</a> call、apply、bind 的区别</h3> <ul><li>都可以改变指针的对象，将函数放到特定作用域中执行</li> <li>call 函数名.call(作用域对象, 多个参数)</li> <li>apply 函数名.apply(作用域对象, 数组参数)</li> <li>bind 绑定作用域 函数名.bind(作用域对象, 多个参数)</li></ul> <h3 id="void-0-与-undefined"><a href="#void-0-与-undefined" class="header-anchor">#</a> void 0 与 undefined</h3> <h3 id="let-与-var-区别"><a href="#let-与-var-区别" class="header-anchor">#</a> let 与 var 区别</h3> <ul><li>var 会全局污染，用 var 声明的变量会挂在 window 全局变量下，用 let 声明的变量则不会；两者都可以跨标签使用。</li> <li>let 有块级作用域</li> <li>let 在执行上下文时会有暂时性死区，不允许在声明前使用变量；var 可以在声明前使用变量，值为 undefined</li> <li>var 允许重复声明，let 不允许重复声明</li></ul> <h3 id="this-指向"><a href="#this-指向" class="header-anchor">#</a> this 指向</h3> <ul><li>通常情况下指向函数的直接调用者，而非间接调用者，如果该对象没有对应属性，则不会再往上一层查找</li> <li>在事件中，this 指向触发这个事件的对象，特殊情况 IE 中 attachEvent 的 this 总是指向 window</li> <li>如果有 new 关键字，this 指向 new 出来的那个对象</li> <li>箭头函数没有自己的 this 如果我们在函数中引用 this，this 值取决于外部“正常的”函数。这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用</li> <li>一个函数在声明时，可能就使用了 this，但是这个 this 只有在函数被调用时才会有值。</li></ul> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <ul><li>在函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链</li> <li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁，用完需要对闭包做 null 的处理手动销毁</li> <li>作用域链，如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，查找过程形成的链条就叫做作用域链</li> <li>优点：
<ul><li>避免全局变量的污染</li> <li>封装对象的私有属性和方法</li></ul></li> <li>缺点：
<ul><li>会常驻内存，增大内存使用量</li> <li>使用不当会造成内存泄露</li></ul></li></ul> <h3 id="混合"><a href="#混合" class="header-anchor">#</a> 混合</h3> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <ul><li>构造继承，函数内使用 call、apply 调用</li> <li>原型继承，设置 prototype 属性</li></ul> <h3 id="模板引擎"><a href="#模板引擎" class="header-anchor">#</a> 模板引擎</h3> <ul><li>模板引擎负责组装数据，将变量模板编译成浏览器能识别的代码</li></ul> <h3 id="flux"><a href="#flux" class="header-anchor">#</a> Flux</h3> <h3 id="同构"><a href="#同构" class="header-anchor">#</a> 同构</h3> <h3 id="浅拷贝"><a href="#浅拷贝" class="header-anchor">#</a> 浅拷贝</h3> <p>只拷贝第一层</p> <ul><li>循环</li> <li>es6 解构</li> <li>Object.assign()</li></ul> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <ul><li>json 转换，正则、函数、会变成{}，日期会变成字符串
<ul><li>不能序列化函数</li> <li>会忽略 undefined</li> <li>不能解决循环引用的对象</li></ul></li> <li>递归，判断正则、日期、函数等特殊类型</li></ul> <h3 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h3> <ul><li>将对象方法封装成相互独立的模块</li> <li>以功能来划分</li></ul> <h3 id="面向过程"><a href="#面向过程" class="header-anchor">#</a> 面向过程</h3> <ul><li>分析出解决问题所需要的步骤，然后一步一步解决</li></ul> <h3 id="多线程实现"><a href="#多线程实现" class="header-anchor">#</a> 多线程实现</h3> <ul><li>单线程原因：避免 dom 渲染的冲突</li> <li>webworker 支持多线程，但是不能操作 dom</li></ul> <h3 id="遍历-异步遍历-提前返回问题"><a href="#遍历-异步遍历-提前返回问题" class="header-anchor">#</a> 遍历（异步遍历，提前返回问题）</h3> <ul><li>forEach(item, index, array) 类似 for 循环，没有返回值。IE 不支持，无法使用 break，continue 跳出循环，使用 return 跳出循环</li> <li>map(item, index) 需要返回值</li> <li>reduce((prev, item, index) =&gt; {}, initValue) 对数组中每个元素执行回调，并将累计结果返回给下一个回调</li> <li>for...in 可以遍历对象</li> <li>for...of</li></ul> <h3 id="模块化开发"><a href="#模块化开发" class="header-anchor">#</a> 模块化开发</h3> <ul><li>立即执行函数不暴露私有属性</li></ul> <h3 id="懒加载原理"><a href="#懒加载原理" class="header-anchor">#</a> 懒加载原理</h3> <ul><li>图片加载是由 src 的值引起的，当对 src 进行赋值时浏览器会请求图片资源，可以用 html5 属性 data-xxx 来保存图片路径，当需要显示图片时，再将 data-xxx 的值赋给 src，实现按需加载</li></ul> <h3 id="异步加载-js"><a href="#异步加载-js" class="header-anchor">#</a> 异步加载 js</h3> <ul><li>defer(只支持 IE)，async</li> <li>创建 script，插入到 dom 中，再执行 callback</li></ul> <h3 id="装饰器"><a href="#装饰器" class="header-anchor">#</a> 装饰器</h3> <ul><li>对类或属性方法加上前置操作</li> <li>实现复用</li></ul> <h3 id="异步"><a href="#异步" class="header-anchor">#</a> 异步</h3> <ul><li>执行顺序，一个宏任务里必须执行完所有微任务才会执行下一个宏任务，同级先微任务后宏任务</li> <li>宏任务：定时器、事件绑定、ajax</li> <li>微任务：async、await、promise</li></ul> <h3 id="fetch"><a href="#fetch" class="header-anchor">#</a> fetch</h3> <ul><li>基于 promise，支持 async/await</li> <li>需要进行封装</li> <li>只对网络请求报错，400，500 均为正常</li> <li>默认不会带 cookie，需要配置项。fetch(url, {credentials: 'include'})</li> <li>不支持超时控制。使用 setTimeout 及 promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行</li> <li>没有办法原生监测请求的进度</li></ul> <h3 id="axios"><a href="#axios" class="header-anchor">#</a> axios</h3> <ul><li>支持浏览器和 nodejs 发请求</li> <li>支持 promise</li> <li>客户端支持防 CSRF</li> <li>提供了一些并发请求的接口</li> <li>拦截请求和响应</li> <li>取消请求</li> <li>自动转换 json 数据</li> <li>监测请求的进度</li></ul> <h3 id="多标签页之间的通信"><a href="#多标签页之间的通信" class="header-anchor">#</a> 多标签页之间的通信</h3> <ul><li>localStorage，页面 a 使用 localStorage.setItem 存储值，页面 b 监听 storage 事件</li> <li>cookie，页面 a 存储值，页面 b 轮询 cookie 值</li> <li>websocket，全双工通信，服务器可以主动发数据，页面 a 发送数据到服务器，服务器发送数据到页面 b</li> <li>sharedWorker，多页面多线程</li></ul> <h3 id="判断类型"><a href="#判断类型" class="header-anchor">#</a> 判断类型</h3> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.toString.call(value).slice(8, -1)
</code></pre></div><ul><li>typeof
<ul><li>对于原始类型来说，除了 null 都可以显示正确的类型</li> <li>对于对象来说，除了函数都会显示 object</li></ul></li> <li>instanceof
<ul><li>可以正确的判断对象的类型，因为内部机制是通过对象 prototype 原型链判断</li></ul></li></ul> <h3 id="比较运算符"><a href="#比较运算符" class="header-anchor">#</a> 比较运算符 ==</h3> <ul><li>对象/数组==字符串，会转换成字符串</li> <li>null==undefined，与其他值不相等</li> <li>NAN!=NAN</li> <li>对象/数组==数字，会先转换成字符串，然后再转换成数字</li> <li>剩下的都是转换成数字</li></ul> <h3 id="事件代理"><a href="#事件代理" class="header-anchor">#</a> 事件代理</h3> <ul><li>把原本需要绑定的事件委托给父元素，让父元素监听处理多个子元素</li> <li>事件代理的原理是 dom 事件冒泡，使用事件代理的好处是可以提高性能，节省内存空间，减少事件注册</li> <li>可以实现新增子对象是无需再次对其绑定</li></ul> <h3 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h3> <ul><li>事件冒泡，子元素先触发，父元素后触发</li> <li>时间捕获，父元素先触发，子元素后触发</li> <li>dom 事件流，同时支持冒泡和捕获，document.addEventListener()，第三个参数 true 表示捕获，false 表示冒泡</li> <li>阻止冒泡，w3c 使用 stopPropagation()，IE 使用 cancelBubble = true</li> <li>阻止捕获，阻止事件的默认行为，w3c 中使用 preventDefault()，IE 中设置 window.event.returnValue = false</li></ul> <h3 id="new-操作符"><a href="#new-操作符" class="header-anchor">#</a> new 操作符</h3> <ul><li><p>1，创建一个新对象，并分配给 this 变量，同时继承该函数的原型；2，函数体执行。通常它会修改 this，为其添加新的属性和方法；3， 返回 this</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// this = {};（隐式创建）</span>
  <span class="token comment">// 添加属性到 this</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>isAdmin <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token comment">// return this;（隐式返回）</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。对于常规调用，它为 undefined，对于使用 new 的调用，则等于该函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 不带 &quot;new&quot;：</span>
<span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token comment">// 带 &quot;new&quot;：</span>
<span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// function User { ... }</span>
</code></pre></div></li></ul> <h3 id="ajax"><a href="#ajax" class="header-anchor">#</a> ajax</h3> <ul><li>创建 xhr 连接</li> <li>设置参数，并打开连接</li> <li>发送请求</li> <li>接收请求</li> <li>优点
<ul><li>异步请求提升了用户体验</li> <li>实现局部数据更新</li></ul></li> <li>缺点
<ul><li>安全问题，ajax 暴露了客户端与服务器交互细节</li> <li>对搜索引擎支持弱，不利于 seo</li></ul></li></ul> <h3 id="内存泄露"><a href="#内存泄露" class="header-anchor">#</a> 内存泄露</h3> <ul><li>闭包使用不当，不需要的对象仍存在于内存中</li> <li>死循环</li></ul> <h3 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h3> <ul><li>在 <code>JavaScript</code> 引擎中有一个被称作 <code>垃圾回收器</code> 的东西在后台执行，它监控着所有对象的状态，并删除掉那些已经不可达的</li> <li>如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的。比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 该 对象被认为是可达的。而且它引用的内容也是可达的</li> <li>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</li> <li>固有的可达值的基本集合，这些值被称作 <code>根</code>（<code>roots</code>）
<ul><li>当前执行的函数，它的局部变量和参数</li> <li>当前嵌套调用链上的其他函数、它们的局部变量和参数</li> <li>全局变量</li></ul></li> <li>定期执行以下“垃圾回收”步骤
<ul><li>垃圾收集器找到所有的根，并“标记”（记住）它们</li> <li>然后它遍历并“标记”来自它们的所有引用</li> <li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象</li> <li>如此操作，直到所有可达的（从根部）引用都被访问到</li> <li>没有被标记的对象都会被删除</li></ul></li></ul> <h3 id="amd-commonjs-es6"><a href="#amd-commonjs-es6" class="header-anchor">#</a> AMD，Commonjs，ES6</h3> <ul><li>AMD 是异步加载模块，允许指定回调函数</li> <li>AMD 推荐通过返回一个对象作为模块对象</li> <li>Commonjs 是服务器端的模块规范，加载模块是同步的，只有模块加载完成才能执行后面的操作</li> <li>Commonjs 推荐通过 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的</li> <li>Commonjs 支持动态导入，例如 require(${path}/xx.js)，导出时是值拷贝，</li> <li>ES6 中一个模块就是一个文件，改文件内左右的变量和方法外部无法直接获取只能通过 export 输出</li> <li>ES6 异步加载，导入导出都指向同一个内存地址</li></ul> <h3 id="window-onload-和-document-ready"><a href="#window-onload-和-document-ready" class="header-anchor">#</a> window.onload 和$(document).ready</h3> <ul><li>window.onload 必须等页面内所有元素（包括图片）加载完毕后才能执行</li> <li>$(document).ready 是 dom 结构绘制完毕后就会执行，不必等到加载完毕</li></ul> <h3 id="判断标准浏览器和-ie-浏览器"><a href="#判断标准浏览器和-ie-浏览器" class="header-anchor">#</a> 判断标准浏览器和 IE 浏览器</h3> <ul><li>标准，document.addEventListener，支持冒泡和捕获，事件类型不需要添加 on，添加多个事件正序执行</li> <li>IE，document.attachEvent，支持冒泡，事件类型需要添加 on，添加多个事件倒序执行</li></ul> <h3 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> event loop</h3> <h3 id="事件流"><a href="#事件流" class="header-anchor">#</a> 事件流</h3> <h3 id="canvas-图片跨域"><a href="#canvas-图片跨域" class="header-anchor">#</a> canvas 图片跨域</h3> <h3 id="map-and-set-映射和集合"><a href="#map-and-set-映射和集合" class="header-anchor">#</a> Map and Set（映射和集合）</h3> <ul><li><p>Map 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。它的方法和属性如下：</p> <ul><li>new Map() —— 创建 map。</li> <li>map.set(key, value) —— 根据键存储值。</li> <li>map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。</li> <li>map.has(key) —— 如果 key 存在则返回 true，否则返回 false。</li> <li>map.delete(key) —— 删除指定键的值。</li> <li>map.clear() —— 清空 map。</li> <li>map.size —— 返回当前元素个数。</li></ul></li> <li><p>对象仅支持 string/symbol 作为键。Map 还可以使用对象作为键</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在 Object 中，我们则无法使用对象作为键。在 Object 中使用字符串作为键是可以的，但我们无法使用另一个 Object 作为 Object 中的键</span>
<span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> ben <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Ben'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> visitsCountObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 尝试使用对象</span>
visitsCountObj<span class="token punctuation">[</span>ben<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">234</span> <span class="token comment">// 尝试将对象 ben 用作键</span>
visitsCountObj<span class="token punctuation">[</span>john<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// 尝试将对象 john 用作键，但我们会发现使用对象 ben 作为键存下的值会被替换掉</span>
<span class="token comment">// 变成这样了！</span>
<span class="token function">alert</span><span class="token punctuation">(</span>visitsCountObj<span class="token punctuation">[</span><span class="token string">'[object Object]'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>
<span class="token comment">// 因为 visitsCountObj 是一个对象，它会将所有 Object 键例如上面的 john 和 ben 转换为字符串 &quot;[object Object]&quot;</span>
</code></pre></div></li> <li><p>Map 使用 SameValueZero 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1，如果我们想从一个已有的普通对象（plain object）来创建一个 Map，那么我们可以使用内建方法 Object.entries(obj)，该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">30</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Object.entries() 返回一个包含该对象所有 [key, value] 键值对的数组。</span>
<span class="token function">alert</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// John</span>

<span class="token comment">// 2，因为 Object.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 map 相同。</span>
<span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'meat'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个普通对象（plain object）(*)</span>
<span class="token comment">// 完成了！</span>
<span class="token comment">// obj = { banana: 1, orange: 2, meat: 4 }</span>
<span class="token function">alert</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>orange<span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div></li> <li><p>Set 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p> <ul><li>new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。</li> <li>set.add(value) —— 添加一个值，返回 set 本身</li> <li>set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。</li> <li>set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。</li> <li>set.clear() —— 清空 set。</li> <li>set.size —— 返回元素个数。</li></ul></li></ul></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/42d342/"><div>烧虾球</div></a> <span>05-13</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/d0e6ce/"><div>二次开发</div></a> <span>12-20</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/0deeda/"><div>文字展开收起</div></a> <span>10-17</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1b920942.js" defer></script><script src="/assets/js/2.a96424b1.js" defer></script><script src="/assets/js/34.d1e49084.js" defer></script>
  </body>
</html>